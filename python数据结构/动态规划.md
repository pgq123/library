### 1.1基础思想

动态规划的基础思想有：1.分治思想，2.空间换时间，3.最优解等

1. **分治**：将原问题分解为若干个子问题，不断递归细分子问题，通过组合子问题的解来得到原问题的解。与分治类似，动态规划也通过组合子问题的解来得到原问题的解，不同的是，适合动态规划的问题具有**重叠子问题**和**最优子结构**两大特性
2. **重叠子问题**：动态规划的子问题在细分为若干个子问题时会出现每个子问题包含重复的子问题的情况，此时若使用暴力穷举法则会产生大量重复计算，效率低下。而动态规划在第一次求解某子问题时，会**将子问题的解保存下来**；后续遇到重叠子问题时会**查表求解**，保证每个独立的子问题只会被计算一次，从而降低算法的时间复杂度
3. **最优子结构**：如果一个问题的最优解可以由它的子问题的最优解组合构成，并且这些子问题可以**独立求解**，则称该问题具有最优解结构。动态规划从基础问题的解开始，不断迭代组合，选择子问题的最优解，最终得到问题的最优解。

### 1.2优化代码示例

#### 1.2.1斐波那契数列

暴力递归

```python3
def fibonacci(n):
    if n==0: return 0
    if n==1: return 1
    return fibonacci(n-1)+fibonacci(n-2)
```

时间复杂度：$O(2^n)$



记忆法递归

```python3
def fibonacci(n, dp):
    if n == 0: return 0           # 返回 f(0)
    if n == 1: return 1           # 返回 f(1)
    if dp[n] != 0: return dp[n]   # 若 f(n) 以前已经计算过，则直接返回记录的解
    dp[n] = fibonacci(n - 1, dp) + fibonacci(n - 2, dp) # 将 f(n) 则记录至 dp
    return dp[n]

# 求第 n 个斐波那契数
def fibonacci_memorized(n):
    dp = [0] * (n + 1) # 用于保存 f(0) 至 f(n) 问题的解
    return fibonacci(n, dp)
```

时间复杂度从$O(2^n)$到$O(n)$


动态规划

```python3
# 求第 n 个斐波那契数
def fibonacci(n):
    if n == 0: return 0       # 若求 f(0) 则直接返回 0
    dp = [0] * (n + 1)        # 初始化 dp 列表
    dp[0], dp[1] = 0, 1       # 初始化 f(0), f(1)
    for i in range(2, n + 1): # 状态转移求取 f(2), f(3), ..., f(n) 
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]              # 返回 f(n)
```

时间复杂度$O(n)$



#### 1.2.2蛋糕最高售价

小力开了一家蛋糕店，并针对不同重量的蛋糕设定了不同售价，分别为：

| 蛋糕重量 | 0 | 1 | 2 | 3 | 4 | 5  | 6  |
| -------- | - | - | - | - | - | -- | -- |
| 售价     | 0 | 2 | 3 | 6 | 7 | 11 | 15 |

问题： 现给定一个重量为$n$的蛋糕，问小力应该如何切分蛋糕，达到最高的蛋糕总售价。

设重量为n，售价为f(n)

```python3
def max_ckae_price(n,price_list):
    dp=[0]*(n+1)
    if n<=1: return price_list[n]
    for j in range(1,n+1):
	for i in range(j):
	    dp[j]=max(dp[j],dp[i]+price_list[j-i])
    return dp[n]
```


### 1.3动态规划解题框架

若确定给定问题具有重叠子问题和最优子结构，那么就可以使用动态规划求解。总体上看，求解可分为四步：

1. **状态定义**： 构建问题最优解模型，包括问题**最优解的定义**、有哪些**计算解的自变量**；
2. **初始状态**： 确定**基础子问题的解**（即已知解），原问题和子问题的解都是以基础子问题的解为起始点，在迭代计算中得到的；
3. **转移方程**： 确定原问题的解与子问题的解之间的关系是什么，以及使用何种**选择规则**从子问题最优解组合中选出原问题最优解；
4. **返回值**： 确定应返回的问题的解是什么，即动态规划**在何处停止迭代**；
